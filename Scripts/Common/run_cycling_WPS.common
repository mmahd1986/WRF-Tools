#!/bin/bash -l 
# NOTE: The -l option makes "bash act as if it had been invoked as a login shell". 
#   Login shells read certain initialization files from your home directory, such 
#   as .bash_profile.
# NOTE: The above makes sure shell is a login shell (this is particularly for AIX, 
#   as it doesn't get that. We could get rid of this, as we are not using AIX 
#   anymore and all systems are now Linux).

# ========================================================================================
# ========= Everything below this line was inserted from run_cycling_WPS.common ==========
# ========================================================================================


# The following environment variables have to be set by now:
# JOBNAME, INIDIR, NODES, TASKS, THREADS, WRFSCRIPT, WPSSCRIPT, SCRIPTDIR, BINDIR
# Optional: -


# Abort if anything goes wrong
set -e 

# Display some info: hostname, uname and JOBNAME
echo
echo "   ================================== Preliminary Info ==================================   "
echo
echo -n "   hostname: "
hostname
echo -n "   uname: "
uname
echo
echo "   ================================== JOBNAME = ${JOBNAME} ==================================   "
echo

# Check if $NEXTSTEP is set, and exit, if not
if [[ -z "${NEXTSTEP}" ]]; then
  echo '   Environment variable $NEXTSTEP not set - aborting!'
  exit 1
fi

# Set current step
CURRENTSTEP="${NEXTSTEP}" 
export CURRENTSTEP
# NOTE: $NEXTSTEP will be overwritten.

# More WPS settings (before machine setup)
export NODES=${WPSNODES} # Number of nodes or processes (depending on system).
export PYTHONVERSION=3 # pyWPS and the related/similar files are now converted to Python 3.
# NOTE: Optional arguments are: $RUNPYWPS, $RUNREAL, $RAMIN & $RAMOUT. ?????
export RUNPYWPS=${RUNPYWPS:-1}
export RUNREAL=${RUNREAL:-1}
# Note: The folders are $METDATA, $REALIN, $REALOUT. $METDATA is defined in the machine 
#   setup, if metgrid files need to be output to disk. ?????

# Setup environment
cd "${INIDIR}"
source "${SCRIPTDIR}/setup_WPS.sh" # Load machine-specific stuff.

# ========================== Run WPS for this step ================================
# Prompt on the screen
echo
echo "   ================================== Launching WPS/REAL for current step: ${CURRENTSTEP} ================================== "
echo
echo -n "   DATE = "
date
# NOTE: The date command is used to display the system date and time.
# Run WPS driver script
cd "${INIDIR}"
eval "${SCRIPTDIR}/execWPS.sh"
# NOTE: We have to use eval here, because ${SCRIPTDIR} is a string.
ERR=$? # Capture exit code.
# Check exit code and abort if error occurred
if [[ $ERR != 0 ]]; then
  echo
  echo "   ================================== WARNING: WPS/REAL step ${CURRENTSTEP} failed ================================== "
  date
  echo
  exit ${ERR} # Abort if error occured.
fi 
# Prompt on screen, if run was successful
echo "   ================================== WPS/REAL step ${CURRENTSTEP} completed ================================== "
echo -e -n "\n   "
date
echo
# Copy driver script into work dir to signal completion 
cp "${INIDIR}/${WPSSCRIPT}" "${WORKDIR}"
# NOTE: This is because job dependencies did not work well during the development
#   of this code. Also this is quite a robust method. It has the advantage that it 
#   also works, if a job gets killed and you have to resubmit.


