#!/bin/bash

# ========================================================================================
# ========= Everything below this line was inserted from run_cycling_WRF.common ==========
# ========================================================================================


# See run_cycling.environment script for environment variables.


# Initialize Error counter
ERR=0 

# Display some info: hostname, uname and JOBNAME
echo
echo "   ================================== Preliminary Info ==================================   "
echo
echo -n "   hostname: "
hostname
echo -n "   uname: "
uname
echo
echo "   ================================== JOBNAME = ${JOBNAME} ==================================   "
echo

# Check if $NEXTSTEP is set, and exit, if not
if [[ -z "${NEXTSTEP}" ]]; then
  echo '   Environment variable $NEXTSTEP not set - aborting!'
  exit 1
fi

# Set current step
CURRENTSTEP="${NEXTSTEP}" 
export NEXTSTEP
export CURRENTSTEP
# NOTE: $NEXTSTEP will be overwritten.

# More WRF settings (before machine setup)
export NODES=${WRFNODES} # Number of nodes or processes (depending on system).
export RUNWRF=1 
# NOTE: Some more related options are: $WRFIN, $WRFOUT and $TABLES.
export RUNREAL=0 
# NOTE: Some more related options are: $RAMIN, $RAMOUT, $REALIN and $REALOUT.
export PYTHONVERSION=3 # pyWPS and the related/similar files are now converted to Python 3.

# Setup environment
cd "${INIDIR}"
source "${SCRIPTDIR}/setup_WRF.sh" # Load machine-specific stuff.

# ========================== Run WPS/pre-processing for next step ================================
# Find next step using cycling.py and CURRENTSTEP
NEXTSTEP=$(python "${SCRIPTDIR}/cycling.py" "${CURRENTSTEP}")
# Launch pre-processing for next step
eval "${SCRIPTDIR}/launchPreP.sh" # Primarily for WPS and real.exe.
ERR=$(( ${ERR} + $? )) # Capture exit code and add to ${ERR}.
# Unset $NOWPS
export NOWPS=''
# NOTE: We need to unset $NOWPS, so the next WRF step will submit a WPS job again.

# ========================== Run WRF for this step ================================
# Prompt on the screen
echo
echo "   ================================== Launching WRF for current step: ${CURRENTSTEP} ================================== "
echo -n -e "\n   "
date
# NOTE: The date command is used to display the system date and time.
# NOTE: We should work in existing working folder, created by caller instance.
#   We shouldn't remove namelist files in working directory.
# Run execution script
eval "${SCRIPTDIR}/execWRF.sh"
ERR=$(( ${ERR} + $? )) # Capture exit code and add to ${ERR}.


# ================ Reload machine setup (might have changed in the meantime) ======================
# Prompt on the screen
echo "   ================================== Reload machine setup (allows easy machine swithing between steps) ================================== "
echo
# Move into INIDIR
cd "${INIDIR}"
# Reset variables that pertain to starting the next job
#   (do not change archiving and averaging settings)
unset WAITFORWPS RESUBJOB SLEEPERJOB PYTHONPATH
# Load machine-specific stuff again
source "${SCRIPTDIR}/setup_WRF.sh" 
# NOTE: This is basically to allow seamless machine switching between steps.

# ================ Check exit code and act accordingly ======================  
# If error code is non-zero
if [[ $ERR != 0 ]]; then
  # Prompt on screen
  echo
  echo "   ======================= WARNING: WRF step ${CURRENTSTEP} failed (leaving Working Directory ${WORKDIR} intact) ======================="
  echo -n -e "\n   "
  date
  echo  
  # Export restart counter 
  export RSTCNT   
  # Launch crash handler script   
  eval "${SCRIPTDIR}/crashHandler.sh" # Restart job with smaller time-step.
  ERR=$(( ${ERR} + $? )) # Capture exit code and add to ${ERR}.
# If WRF completed successfully  
else
  # Prompt on screen
  echo
  echo "   ================================== WRF step ${CURRENTSTEP} completed =================================="
  echo -n -e "\n   "
  date
  # Launch post-processing
  eval "${SCRIPTDIR}/launchPostP.sh" # Mainly archiving, but may include actual post-processing.
  ERR=$(( ${ERR} + $? )) # Capture exit code and add to ${ERR}.
  # Reset restart counter
  export RSTCNT=0
  # Resubmit job for next step   
  eval "${SCRIPTDIR}/resubJob.sh" 
  ERR=$(( ${ERR} + $? )) # Capture exit code and add to ${ERR}.
  # Display extra line
  echo  
  # Remove working directory if everything was successful  
  cd "${INIDIR}"
  if [[ $ERR == 0 ]]; then
    echo "   Removing Working Directory: ${WORKDIR}."
    rm -rf "${WORKDIR}"
    echo
  else
    echo "   WARNING: ${ERR} Error(s) encountered after WRF completed!!!"
    echo "   Leaving Working Directory ${WORKDIR} intact."
    echo
  fi 
fi 

# ================ Exit with number of errors as exit code ====================== 
exit ${ERR} 











